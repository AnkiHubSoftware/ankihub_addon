"""Logic for the initial steps of registering local decks with collaborative
decks for both deck creators and deck users.
"""
import json
import os
import pathlib
import tempfile
import uuid
import typing

from PyQt6.QtCore import qDebug
from anki.errors import NotFoundError
from anki.exporting import AnkiPackageExporter
from anki.models import NoteType
from anki.notes import Note
from aqt import mw
from aqt.dbcheck import check_db
from aqt.utils import askUser, tooltip

from . import constants
from .ankihub_client import AnkiHubClient
from .utils import get_note_types_in_deck

DIR_PATH = os.path.dirname(os.path.abspath(__file__))


def populate_ankihub_id_fields(notes: typing.List[dict]) -> None:
    """Populate the AnkiHub ID field that was added to the Note Type by
    modify_note_type."""
    updated_notes, = []
    for note_data in notes:
        (
            ankihub_id,
            anki_id,
            tags,
            deck,
            last_sync,
            fields,
            note_type,
            note_type_id,
        ) = note_data.values()
        # the fields column generated by parse_notes_to_csv isnâ€™t valid json
        fields = json.loads(fields.replace("'", '"'))
        tags = json.loads(tags.replace("'", '"'))
        try:
            note = mw.col.get_note(id=int(anki_id))
            note["AnkiHub ID"] = ankihub_id
            updated_notes.append(note)
        except NotFoundError:
            note_type = mw.col.models.by_name(note_type)
            note = Note(col=mw.col, model=note_type)
            note["AnkiHub ID"] = ankihub_id
            note.tags = tags
            for field in fields:
                note[field["name"]] = field["value"]
            # TODO Add to an appropriate deck.
            mw.col.add_note(note, 1)
            # Swap out the note id that Anki assigns to the new note with our own id.
            sql = (
                f"UPDATE notes SET id={anki_id} WHERE id={note.id};"
                f"UPDATE cards SET nid={anki_id} WHERE nid={note.id};"
            )
            mw.col.db.execute(sql)
    mw.col.update_notes(updated_notes)
    check_db(mw)


def modify_note_type(note_type: NoteType) -> None:
    """Adds the AnkiHub Field to the Note Type and modifies the template to
    display the field.
    """
    "Adds ankihub field. Adds link to ankihub in card template."
    qDebug(f"modifying note type {note_type}")
    mm = mw.col.models
    fields = note_type["flds"]
    field_names = [field["name"] for field in fields]
    if constants.ANKIHUB_NOTE_TYPE_FIELD_NAME in field_names:
        qDebug(f"{constants.ANKIHUB_NOTE_TYPE_FIELD_NAME} already exists.")
        return
    ankihub_field = mm.new_field(constants.ANKIHUB_NOTE_TYPE_FIELD_NAME)
    # Put our field last.
    ankihub_field["ord"] = len(fields)
    ankihub_field["size"] = 0
    mm.add_field(note_type, ankihub_field)
    # TODO Genericize this by creating a function that takes a template and
    #  returns a new template.
    link_html = "".join(
        (
            "\n{{#%s}}\n" % constants.ANKIHUB_NOTE_TYPE_FIELD_NAME,
            "<a class='ankihub' href='%s'>"
            % (
                constants.URL_VIEW_NOTE
                + "{{%s}}" % constants.ANKIHUB_NOTE_TYPE_FIELD_NAME
            ),
            "\nView Note on AnkiHub\n",
            "</a>",
            "\n{{/%s}}\n" % constants.ANKIHUB_NOTE_TYPE_FIELD_NAME,
        )
    )
    templates = note_type["tmpls"]
    for template in templates:
        template["afmt"] += link_html
    mm.save(note_type)


def modify_note_types(note_types: typing.Iterable[str]):
    for note_type in note_types:
        qDebug(f"Getting note type {note_type}")
        note_type = mw.col.models.by_name(note_type)
        modify_note_type(note_type)
    # TODO Run add_id_fields


def upload_deck(did: int) -> None:
    """Upload the deck to AnkiHub."""
    deck_name = mw.col.decks.name(did)
    exporter = AnkiPackageExporter(mw.col)
    exporter.did = did
    exporter.includeMedia = False
    exporter.includeTags = True
    deck_uuid = uuid.uuid4()
    out_dir = pathlib.Path(tempfile.mkdtemp())
    out_file = str(out_dir / f"export-{deck_uuid}.apkg")
    exporter.exportInto(out_file)
    ankihub_client = AnkiHubClient()
    response = ankihub_client.upload_deck(f"{deck_name}.apkg")
    tooltip("Deck Uploaded to AnkiHub")
    return response


def _create_collaborative_deck(note_types, did):
    modify_note_types(note_types)
    upload_deck(did)


def create_collaborative_deck(did: int) -> None:
    model_ids = get_note_types_in_deck(did)
    note_types = [mw.col.models.get(model_id) for model_id in model_ids]
    names = ", ".join([note["name"] for note in note_types])
    response = askUser(
        "Uploading the deck to AnkiHub will modify the following note types, "
        f"and will require a full sync afterwards: {names}.  Continue?",
        title="AnkiHub",
    )
    if not response:
        tooltip("Cancelled Upload to AnkiHub")
        return
    mw.taskman.with_progress(
        task=lambda: _create_collaborative_deck(note_types, did),
        on_done=lambda future: tooltip("Deck Uploaded to AnkiHub"),
    )
